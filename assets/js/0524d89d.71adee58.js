"use strict";(self.webpackChunkportal=self.webpackChunkportal||[]).push([[40],{7164:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var n=o(7624),a=o(2172);const i={title:"Security",sidebar_position:6,description:"Resistance to attacks",keywords:["Consensus","Security","Attacks"],last_update:{date:"05/02/2024",author:"Saeid Yazdinejad"}},s=void 0,r={id:"consensus/security",title:"Security",description:"Resistance to attacks",source:"@site/docs/consensus/security.md",sourceDirName:"consensus",slug:"/consensus/security",permalink:"/docs/consensus/security",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Saeid Yazdinejad",lastUpdatedAt:1714600800,formattedLastUpdatedAt:"May 1, 2024",sidebarPosition:6,frontMatter:{title:"Security",sidebar_position:6,description:"Resistance to attacks",keywords:["Consensus","Security","Attacks"],last_update:{date:"05/02/2024",author:"Saeid Yazdinejad"}},sidebar:"tutorialSidebar",previous:{title:"Proof-of-Time",permalink:"/docs/consensus/pot"},next:{title:"Network Architecture",permalink:"/docs/category/network-architecture"}},c={},l=[{value:"Security against general blockchain attacks",id:"security-against-general-blockchain-attacks",level:2},{value:"Grinding on block challenges",id:"grinding-on-block-challenges",level:3},{value:"Costless simulation",id:"costless-simulation",level:3},{value:"C-correlation predictability window",id:"c-correlation-predictability-window",level:3},{value:"Long-range attacks",id:"long-range-attacks",level:3},{value:"Security against attacks on Proof-of-Storage",id:"security-against-attacks-on-proof-of-storage",level:2},{value:"Time-Memory algorithms (plot compression)",id:"time-memory-algorithms-plot-compression",level:3},{value:"On-the-fly plot creation",id:"on-the-fly-plot-creation",level:3}];function h(e){const t={a:"a",h2:"h2",h3:"h3",p:"p",...(0,a.M)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"A complex system like the Autonomys Network protocol, Subspace, has many potential attack vectors, some are more general, blockchain related,\nwhile other are focused on Proof-of-Space and specifically Proof-of-Archival-Storage, as used in Autonomys Network."}),"\n",(0,n.jsxs)(t.p,{children:["This page gives an overview of how such attacks are mitigated in the Subspace protocol. There are many things\nto cover, so the reader should be aware that at the current state this page is not exhaustive. Furthermore, the\npresentation mostly highlights the techniques and methods, without the full technical details.\nFor detailed security analysis please refer to our paper ",(0,n.jsx)(t.a,{href:"https://github.com/subspace/consensus-v2-research-paper",children:"Dilithium: A Proof-of-Archival-Storage Consensus Protocol for Subspace"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"security-against-general-blockchain-attacks",children:"Security against general blockchain attacks"}),"\n",(0,n.jsx)(t.h3,{id:"grinding-on-block-challenges",children:"Grinding on block challenges"}),"\n",(0,n.jsx)(t.p,{children:"To prevent grinding on block challenges, we use the Proof-of-Time outputs to draw unique challenges."}),"\n",(0,n.jsx)(t.p,{children:'In proof-of-work-based blockchains the "challenge" for block creation comes from the full previous block.\nThe Subspace protocol cannot follow this approach, as changing the block content does not affect the proof-of-space\nvalidity. Instead, challenges are unique (and unpredictable), and are based on the network\'s Proof-of-Time component.\nIn more detail, the blockchain progress is based on "time slots", where each slot is associated with a run of the\nProof-of-Time algorithm. We use the algorithm output to draw a block challenge for this slot. By design, grinding\non Proof-of-Time is extremely hard.'}),"\n",(0,n.jsxs)(t.p,{children:["For more information about the Proof-of-Time component see ",(0,n.jsx)(t.a,{href:"/docs/consensus/pot",children:"this page"}),"."]}),"\n",(0,n.jsx)(t.h3,{id:"costless-simulation",children:"Costless simulation"}),"\n",(0,n.jsx)(t.p,{children:"To mitigate against the costless simulation attack that can lead the attacker to create blocks in a greater proportion\nthan the proportion of disk space they pledge to the network, we use correlated randomness in block challenges."}),"\n",(0,n.jsx)(t.p,{children:"Subspace uses the c-correlation method, where challenges for 'c' blocks are correlated and deterministic. Using this\napproach, an attacker who tries to simulate many potential forks gains significantly less power, as the ability to\nmanoeuvre across these forks becomes more and more limited as 'c' gets larger."}),"\n",(0,n.jsx)(t.h3,{id:"c-correlation-predictability-window",children:"C-correlation predictability window"}),"\n",(0,n.jsx)(t.p,{children:"Even though the challenges for 'c' blocks are deterministic, since we use Proof-of-Time to draw the challenges, they are\nnot known in advanced, but only revealed when the timeslot arrives (by definition). This prevents potential issues, like\nso-called \"bribing attacks\", that come with the correlation of block challenges and the predictability window associated\nwith c-correlation in general."}),"\n",(0,n.jsx)(t.h3,{id:"long-range-attacks",children:"Long-range attacks"}),"\n",(0,n.jsx)(t.p,{children:"To prevent long-range attacks, we use Proof-of-Time as a fundamental component in our consensus protocol."}),"\n",(0,n.jsx)(t.p,{children:"Attackers that try to bootstrap a competing and longer (i.e. heavier) chain cannot do it without cost, since they must\nshow that sufficient time has passed for the lifespan of this fork. In other words, like in Proof-of-Work, they must\nspend a significant amount of sequential work in maintaining the attack."}),"\n",(0,n.jsxs)(t.p,{children:["For more information about how Proof-of-Time is used see ",(0,n.jsx)(t.a,{href:"/docs/consensus/pot",children:"this page"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"security-against-attacks-on-proof-of-storage",children:"Security against attacks on Proof-of-Storage"}),"\n",(0,n.jsx)(t.p,{children:"The masking function that we apply during farmer's plot creation has specific properties that help us in preventing the\nfollowing attacks on the protocol."}),"\n",(0,n.jsx)(t.h3,{id:"time-memory-algorithms-plot-compression",children:"Time-Memory algorithms (plot compression)"}),"\n",(0,n.jsxs)(t.p,{children:["We adopt the function described in the work ",(0,n.jsx)(t.a,{href:"https://eprint.iacr.org/2017/893",children:'"Beyond Hellman\'s Time-Memory Trade-Offs with Applications to Proofs of Space"'}),"\nas our masking function. This function is designed such that the gain in trading computation (time) over storage (memory)\nis very small."]}),"\n",(0,n.jsx)(t.h3,{id:"on-the-fly-plot-creation",children:"On-the-fly plot creation"}),"\n",(0,n.jsx)(t.p,{children:'Preventing farmers from creating plots on the fly, after seeing the challenge, has two flavors.\nFirst, the masking function is memory hard, which means that creating a plot is constrained by the amount of memory the\nfarmer has, as well as the rate of the memory IO operations it can perform.\nSecondly, creating plots on demand is not economical, hence not a rational choice. Because of the different resource\nrequirements in running the masking function, the cost of running it to simulate some (sufficiently high) amount of\nstorage is significantly higher than the cost of purchasing this amount of storage, plotting once (more precisely,\naccording to the protocol specification) and maintaining a farmer. In other words, a farmer who is willing to spend the\ncost for on-demand plotting is better off spending this cost on "real" plotting.'})]})}function d(e={}){const{wrapper:t}={...(0,a.M)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},2172:(e,t,o)=>{o.d(t,{I:()=>r,M:()=>s});var n=o(1504);const a={},i=n.createContext(a);function s(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);