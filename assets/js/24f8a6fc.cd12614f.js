"use strict";(self.webpackChunkportal=self.webpackChunkportal||[]).push([[352],{8204:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>t,metadata:()=>o,toc:()=>l});var n=i(7624),a=i(2172);const t={id:"crypto_primitives",title:"Cryptographic Primitives",sidebar_position:1,description:"Cryptographic Primitives used in Autonomys Network protocol",keywords:["Cryptography","Consensus"],last_update:{date:"05/02/2024",author:"Saeid Yazdinejad"}},r=void 0,o={id:"consensus/consensus/crypto_primitives",title:"Cryptographic Primitives",description:"Cryptographic Primitives used in Autonomys Network protocol",source:"@site/docs/consensus/consensus/crypto_primitives.md",sourceDirName:"consensus/consensus",slug:"/consensus/consensus/crypto_primitives",permalink:"/docs/consensus/consensus/crypto_primitives",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Saeid Yazdinejad",lastUpdatedAt:1714600800,formattedLastUpdatedAt:"May 1, 2024",sidebarPosition:1,frontMatter:{id:"crypto_primitives",title:"Cryptographic Primitives",sidebar_position:1,description:"Cryptographic Primitives used in Autonomys Network protocol",keywords:["Cryptography","Consensus"],last_update:{date:"05/02/2024",author:"Saeid Yazdinejad"}},sidebar:"tutorialSidebar",previous:{title:"Proof-of-Archival-Storage",permalink:"/docs/category/proof-of-archival-storage"},next:{title:"Archiving",permalink:"/docs/consensus/consensus/archiving"}},c={},l=[{value:"Hash",id:"hash",level:2},{value:"Digital Signature",id:"digital-signature",level:2},{value:"Erasure Code",id:"erasure-code",level:2},{value:"Kate-Zaverucha-Goldberg (KZG) Polynomial Commitment",id:"kate-zaverucha-goldberg-kzg-polynomial-commitment",level:2},{value:"Merkle Tree",id:"merkle-tree",level:2},{value:"Encoding Mapping",id:"encoding-mapping",level:2}];function h(e){const s={a:"a",annotation:"annotation",em:"em",h2:"h2",li:"li",math:"math",mi:"mi",mn:"mn",mrow:"mrow",msub:"msub",p:"p",semantics:"semantics",span:"span",ul:"ul",...(0,a.M)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.p,{children:"The Autonomys Network protocol, Subspace, uses the following cryptographic primitives:"}),"\n",(0,n.jsx)(s.h2,{id:"hash",children:"Hash"}),"\n",(0,n.jsx)(s.p,{children:"Hashing provides succinct commitments to arbitrary data (blocks, transactions) that are deterministic, verifiable and cannot feasibly be reversed. The Subspace protocol uses the BLAKE2b-256 and BLAKE3 hash functions in different places."}),"\n",(0,n.jsx)(s.h2,{id:"digital-signature",children:"Digital Signature"}),"\n",(0,n.jsx)(s.p,{children:"Digital signature scheme secures different parts of consensus by providing a means of authentication."}),"\n",(0,n.jsxs)(s.p,{children:["We currently use Schnorr/Ristretto x25519 (also known as sr25519) as the key derivation and signing algorithm (with the ",(0,n.jsx)(s.a,{href:"https://github.com/w3f/schnorrkel",children:"schnorrkel"})," library)."]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Non-canonical Schnorr signatures are used to sign rewards for a newly forged block (as defined in Substrate) and votes by farmers, as well as transactions and transaction bundles by domain operators."}),"\n",(0,n.jsx)(s.li,{children:"Canonical (deterministic) signatures are used as a verifiable random function (VRF) in the slot leader election among domain operators. A canonical scheme is necessary for these cases to prevent attackers from repeatedly signing until they produce an election solution that meets the threshold (as part of a grinding attack)."}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"erasure-code",children:"Erasure Code"}),"\n",(0,n.jsx)(s.p,{children:"An erasure code extends the given data so that the original data can be recovered from a subset and protected against loss.\nIn Subspace, erasure code is used to encode and decode blockchain history pieces and their KZG commitments in an archived segment. Erasure coding allows for distributed storage of pieces across farmers and helps protect the data against loss in the event of any failures and network partitions. Erasure code is also used in plotting together with proofs-of-space to create unique, easily recoverable plot files for each farmer."}),"\n",(0,n.jsxs)(s.p,{children:["We currently use a Discrete Fourier Transform-based systematic Reed-Solomon code with a rate of ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mn,{children:"1"}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"/"}),(0,n.jsx)(s.mn,{children:"2"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"1/2"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mord",children:"1/2"})]})})]})," over the field ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsxs)(s.msub,{children:[(0,n.jsx)(s.mi,{children:"F"}),(0,n.jsx)(s.mi,{children:"r"})]})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"F_{r}"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"F"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.1514em"},children:(0,n.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:(0,n.jsx)(s.span,{className:"mord mathnormal mtight",style:{marginRight:"0.02778em"},children:"r"})})})]})}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(s.span,{})})})]})})]})]})})]}),", where ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsx)(s.mi,{children:"r"})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"r"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.4306em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"r"})]})})]})," is the ",(0,n.jsx)(s.a,{href:"https://hackmd.io/@benjaminion/bls12-381#Curve-equation-and-parameters",children:"size of subgroup of points"})," on the BLS12-381 curve for the piece chunks and the same approach over the subgroup of elliptic curve points ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsxs)(s.msub,{children:[(0,n.jsx)(s.mi,{children:"G"}),(0,n.jsx)(s.mn,{children:"1"})]})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"G_1"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord mathnormal",children:"G"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:"1"})})]})}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(s.span,{})})})]})})]})]})})]})," for piece commitments."]}),"\n",(0,n.jsx)(s.h2,{id:"kate-zaverucha-goldberg-kzg-polynomial-commitment",children:"Kate-Zaverucha-Goldberg (KZG) Polynomial Commitment"}),"\n",(0,n.jsx)(s.p,{children:"KZG polynomial commitment scheme allows for *constant-*sized inclusion proofs for arbitrary-sized data sets. Specifically:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["The commitment size is ",(0,n.jsx)(s.em,{children:"constant"})," and equal to one elliptic curve point of an elliptic curve group that admits pairings."]}),"\n",(0,n.jsxs)(s.li,{children:["The witness size is ",(0,n.jsx)(s.em,{children:"constant"})," and equal to one curve point."]}),"\n",(0,n.jsxs)(s.li,{children:["Verification time is ",(0,n.jsx)(s.em,{children:"constant"})," and requires two point-scalar multiplications and two pairings regardless of the size of the committed data set."]}),"\n",(0,n.jsxs)(s.li,{children:["Proving time (commitment and witness generation) is ",(0,n.jsx)(s.em,{children:"linear"})," in the size of committed data.\nSubspace uses BLS12-381, which has 48 bytes for elliptic curve points (commitments and witnesses) serialized in compressed form."]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"The protocol uses the KZG commitment scheme to commit to the archived pieces of history and segments of pieces so that the farmers storing pieces in their plots can always succinctly prove that a particular piece is a valid part of the blockchain history and clients who request pieces can verify the proofs efficiently.\nThe synergy between KZG and Reed-Solomon erasure code allows us to have:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"succinct commitments to data of arbitrary size,"}),"\n",(0,n.jsx)(s.li,{children:"succinct witness of the inclusion of data fragments in blockchain history,"}),"\n",(0,n.jsx)(s.li,{children:"efficient verification"}),"\n",(0,n.jsx)(s.li,{children:"provably correct erasure coding"}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"KZG requires a one-time trusted setup of the universal reference values (public parameters). In the spirit of interoperability, Subspace uses the same reference values as Ethereum, computed during a distributed multi-party computation ceremony held by the Ethereum Foundation. This choice allows cross-chain compatibility of KZG proofs between Subspace and Ethereum."}),"\n",(0,n.jsx)(s.h2,{id:"merkle-tree",children:"Merkle Tree"}),"\n",(0,n.jsxs)(s.p,{children:["Merkle tree provides succinct commitments (Merkle roots) to arbitrary-sized data sets with efficient ",(0,n.jsx)(s.em,{children:"logarithmic"}),"-sized inclusion proofs. Current usages in Subspace include Merkle trees for:"]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"extrinsics sets in blocks (as defined in the Substrate framework)"}),"\n",(0,n.jsx)(s.li,{children:"state of the blockchain (as defined in the Substrate framework)"}),"\n",(0,n.jsx)(s.li,{children:"execution traces for the domain blocks"}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"encoding-mapping",children:"Encoding Mapping"}),"\n",(0,n.jsx)(s.p,{children:"Encoding provides a means to make arbitrary useful data (i.e. chunks of blockchain history) look like random data while allowing retrieval of the useful data through decoding. Subspace uses simple XOR as an encoding function."})]})}function d(e={}){const{wrapper:s}={...(0,a.M)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},2172:(e,s,i)=>{i.d(s,{I:()=>o,M:()=>r});var n=i(1504);const a={},t=n.createContext(a);function r(e){const s=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(t.Provider,{value:s},e.children)}}}]);