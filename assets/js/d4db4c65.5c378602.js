"use strict";(self.webpackChunkportal=self.webpackChunkportal||[]).push([[420],{4268:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>n,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var a=r(7624),i=r(2172);const s={title:"Distributed Storage Network",sidebar_position:2,description:"Distributed Storage Network",keywords:["Consensus","Network","Storage","DSN"],last_update:{date:"05/01/2024",author:"Saeid Yazdinejad"}},n=void 0,o={id:"network/dsn",title:"Distributed Storage Network",description:"Distributed Storage Network",source:"@site/docs/network/dsn.md",sourceDirName:"network",slug:"/network/dsn",permalink:"/docs/network/dsn",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Saeid Yazdinejad",lastUpdatedAt:1714514400,formattedLastUpdatedAt:"Apr 30, 2024",sidebarPosition:2,frontMatter:{title:"Distributed Storage Network",sidebar_position:2,description:"Distributed Storage Network",keywords:["Consensus","Network","Storage","DSN"],last_update:{date:"05/01/2024",author:"Saeid Yazdinejad"}},sidebar:"tutorialSidebar",previous:{title:"Node Types and Roles",permalink:"/docs/network/nodes"},next:{title:"Networking Protocols",permalink:"/docs/network/network_protocols"}},l={},c=[{value:"Layers",id:"layers",level:2},{value:"Pieces cache layer(L2)",id:"pieces-cache-layerl2",level:3},{value:"Archival Storage layer(L1)",id:"archival-storage-layerl1",level:3},{value:"Cache types by peer roles",id:"cache-types-by-peer-roles",level:2}];function h(e){const t={a:"a",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.M)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"To ensure every piece of the blockchain history is recoverable, no matter how large it grows, Subspace organizes farmers into a Distributed Storage Network (DSN), which ensures both the ephemeral and permanent availability of all chain data."}),"\n",(0,a.jsx)(t.p,{children:"The DSN ensures the blockchain history is distributed across the farmer network in a way that is:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"uniform and consistent over time, where each piece is, on average, replicated the same number of times across the network."}),"\n",(0,a.jsx)(t.li,{children:"durable, such that with high probability, no piece may be forgotten,\nwhether accidentally or through malicious intent."}),"\n",(0,a.jsx)(t.li,{children:"retrievable, both in full and for any single piece"}),"\n",(0,a.jsx)(t.li,{children:"load-balanced evenly across all farmers, allowing the overhead of serving history to remain negligible, given that some farmers may only be able to store a partial replica of the history. In contrast, others may be able to store it many times over."}),"\n",(0,a.jsx)(t.li,{children:"stored in an efficiently verifiable manner, as farmers are not expected to either synchronize or retain the entire history"}),"\n",(0,a.jsx)(t.li,{children:"permissionless, without any central coordination"}),"\n",(0,a.jsx)(t.li,{children:"accounting for the dynamic availability of farmers and the uneven growth of the history over time."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The Subspace DSN achieves the above by leveraging consistent hashing, erasure coding, and a Kademlia Distributed Hash Table (K-DHT). To incentivize the farmer network to maintain the desired replication factor for the history, Autonomys Network introduces a novel algorithm that dynamically adjusts the cost of on-chain storage, or blockspace, in response to fluctuations in supply and demand for storage. These features allow the history to bloat well beyond the storage capacity of any single farmer while letting each farmer pledge as much or as little space as they desire."}),"\n",(0,a.jsx)(t.h2,{id:"layers",children:"Layers"}),"\n",(0,a.jsx)(t.p,{children:"The DSN consists of multiple distinctive layers. While all layers serve as pieces of history, they work together to ensure different aspects of data availability, durability and efficient retrievability."}),"\n",(0,a.jsx)(t.h3,{id:"pieces-cache-layerl2",children:"Pieces cache layer(L2)"}),"\n",(0,a.jsx)(t.p,{children:"The pieces cache layer serves to get pieces for data reconstruction and farming efficiently. The primary purpose of this layer is to reduce the latency of piece retrieval. Retrieval of pieces from Archival Storage requires farmers to read and decode their plotted sectors, which is a computationally intensive operation that currently takes ~1 second. In contrast, retrieval of pieces from L2 is almost instant as they are kept in disk cache in unencoded form. For this reason, the default way to acquire pieces is getting them from L2."}),"\n",(0,a.jsx)(t.p,{children:"The L2 cache stores pieces in the DHT by the proximity of the piece index hash to the peer ID. While any peer can store pieces in the L2 cache, we mostly rely on farmers as the most suitable candidates for pieces L2. Farmers dedicate a tiny part of their pledged storage space to store L2 pieces. Several farmers closest to each other as peers by peer ID may store the same piece, determined by the overall storage network replication factor."}),"\n",(0,a.jsx)(t.p,{children:"The piece cache layer is populated as follows:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Nodes produce new segments of pieces during the Archiving process."}),"\n",(0,a.jsx)(t.li,{children:"Nodes temporarily store in their cache the new segments they produce."}),"\n",(0,a.jsx)(t.li,{children:"Farmers receive the segment index from the latest block header from the connected node."}),"\n",(0,a.jsx)(t.li,{children:"Farmers derive the piece index hashes from the segment index and compare their peer ID with those hashes to determine whether they should download any pieces from this segment to their L2."}),"\n",(0,a.jsx)(t.li,{children:"Farmers pull relevant pieces to their local L2 cache."}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"archival-storage-layerl1",children:"Archival Storage layer(L1)"}),"\n",(0,a.jsx)(t.p,{children:"The Archival Storage layer is the fundamental layer responsible for the permanent storage and durability of all chain data. It consists of all storage pledged by farmers to store encoded pieces of chain history."}),"\n",(0,a.jsxs)(t.p,{children:["This layer stores the blockchain history data in the encoded form as an integral part of the ",(0,a.jsx)(t.a,{href:"/docs/category/consensus",children:"Dilithium consensus"}),". It stores the pieces encoded into plot sectors in SSD files."]}),"\n",(0,a.jsx)(t.p,{children:'The Archival Storage layer serves as the "cold storage" and guarantees the history pieces are available when they couldn\'t be retrieved from L2. Retrieval from Archival storage, however, consumes a moderate amount of time and resources and is expected to be used only in the rare event of L2 cache miss.\nIn most cases, the L1 layers of farmers are populated with pieces received from L2.'}),"\n",(0,a.jsxs)("div",{align:"center",children:[(0,a.jsx)("img",{src:"/img/DSN_Layers-light.svg#gh-light-mode-only",alt:"DSN_Layers"}),(0,a.jsx)("img",{src:"/img/DSN_Layers-dark.svg#gh-dark-mode-only",alt:"DSN_Layers"})]}),"\n",(0,a.jsx)(t.h2,{id:"cache-types-by-peer-roles",children:"Cache types by peer roles"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Node cache"})," contains newly archived pieces from the latest segments. It is limited to a few recent segments and gradually replaces older pieces with new data."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Farmer cache"})," contains pieces in the L2 cache automatically populated upon receiving the new archived segment announcements. Pieces are cached according to the proximity to the farmer's peer ID."]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.M)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},2172:(e,t,r)=>{r.d(t,{I:()=>o,M:()=>n});var a=r(1504);const i={},s=a.createContext(i);function n(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:n(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);